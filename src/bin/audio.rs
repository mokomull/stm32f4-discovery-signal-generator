#![no_main]
#![no_std]

use cortex_m::iprintln;
use cortex_m_rt::entry;
use panic_itm as _;

use stm32f4xx_hal::prelude::*;

// generated by: [int(0x7fff * math.sin(2*math.pi/16 * t)) for t in range(0, 16)]
static SINES: &[i16] = &[
    0, 12539, 23169, 30272, 32767, 30272, 23169, 12539, 0, -12539, -23169, -30272, -32767, -30272,
    -23169, -12539,
];

#[entry]
fn main() -> ! {
    let peripherals = stm32f407g_disc::Peripherals::take().unwrap();
    let mut core_peripherals = cortex_m::Peripherals::take().unwrap();

    let rcc = peripherals.RCC.constrain();
    let clocks = rcc.cfgr.use_hse(8.mhz()).sysclk(168.mhz()).freeze();

    let itm = &mut core_peripherals.ITM.stim[0];

    let porta = peripherals.GPIOA.split();

    // the DAC overrides what was selected in the GPIO module, but the datasheet recommended the pin
    // be switched to analog input.
    let _signal_out = porta.pa4.into_analog();

    // enable the DAC peripheral
    unsafe {
        let rcc = &*stm32f4xx_hal::stm32::RCC::ptr();
        rcc.apb1enr.modify(|_r, w| w.dacen().set_bit());
    }
    let dac = peripherals.DAC;

    dac.dhr12r1.write(|w| unsafe { w.dacc1dhr().bits(0x200) });
    dac.cr.write(|w| {
        w.en1().set_bit();
        w.mamp1().bits(0x8);
        w.wave1().triangle();
        w.ten1().enabled();
        w.tsel1().software()
    });

    // dac.dhr12r1.write(|w| unsafe { w.bits(0xfff) });

    loop {
        dac.swtrigr.write(|w| w.swtrig1().set_bit());
    }
}
