#![no_main]
#![no_std]

use cortex_m::iprintln;
use cortex_m_rt::entry;
use panic_itm as _;

use stm32f4xx_hal::prelude::*;

// generated by: [int(0x7ff * math.sin(2*math.pi/16 * t)) + 0x800 for t in range(0, 16)]
static SINES: &[u16] = &[
    2048, 2831, 3495, 3939, 4095, 3939, 3495, 2831, 2048, 1265, 601, 157, 1, 157, 601, 1265,
];

#[entry]
fn main() -> ! {
    let peripherals = stm32f407g_disc::Peripherals::take().unwrap();
    let mut core_peripherals = cortex_m::Peripherals::take().unwrap();

    let rcc = peripherals.RCC.constrain();
    let clocks = rcc.cfgr.use_hse(8.mhz()).sysclk(168.mhz()).freeze();

    let itm = &mut core_peripherals.ITM.stim[0];

    let porta = peripherals.GPIOA.split();

    // the DAC overrides what was selected in the GPIO module, but the datasheet recommended the pin
    // be switched to analog input.
    let _signal_out = porta.pa4.into_analog();

    // enable the DAC peripheral
    unsafe {
        let rcc = &*stm32f4xx_hal::stm32::RCC::ptr();
        rcc.apb1enr.modify(|_r, w| {
            w.dacen().set_bit();
            w.tim3en().set_bit()
        });
    }
    let dac = peripherals.DAC;
    let timer = peripherals.TIM3;
    // 84MHz (since I suppose the APBx prescaler causes the timer clock to be doubled) / 16kHz
    timer.arr.write(|w| w.arr().bits(5250));
    timer.cr1.write(|w| w.cen().set_bit());

    dac.cr.write(|w| w.en1().set_bit());

    loop {
        for &value in SINES {
            while !timer.sr.read().uif().bit() {}
            timer.sr.modify(|_r, w| w.uif().clear_bit());

            dac.dhr12r1.write(|w| unsafe { w.dacc1dhr().bits(value) });
        }
    }
}
